//
// Copyright 2021 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// mtl_msl_vertex_fetch_codegen: utils to generate vertex fetch code into msl code.
//

#include "libANGLE/renderer/metal/mtl_msl_vertex_fetch_codegen.h"

#include <functional>
#include <regex>
#include <sstream>

#include "libANGLE/renderer/metal/mtl_state_cache.h"

namespace rx
{
namespace mtl
{
namespace
{

// Size = num components
// Type = component type
constexpr int kVertexTypeConstBaseIdx          = 100;
constexpr int kVertexSizeConstBaseIdx          = 200;
constexpr int kVertexDivisorConstBaseIdx       = 500;
constexpr int kVertexNormalizeConstBaseIdx     = 600;
constexpr int kVertexOffsetAlignedConstBaseIdx = 700;

constexpr char kVertexTypeConstBaseName[]          = "ANGLEVertexAttribType";
constexpr char kVertexSizeConstBaseName[]          = "ANGLEVertexAttribSize";
constexpr char kVertexDivisorConstBaseName[]       = "ANGLEVertexAttribDivisor";
constexpr char kVertexNormalizeConstBaseName[]     = "ANGLEVertexAttribNormalize";
constexpr char kVertexOffsetAlignedConstBaseName[] = "ANGLEVertexAttribOffsetAligned";

constexpr char kVertexBufferPrefix[] = "ANGLEVertexAttribBuffer";

constexpr char kVertexOffsetStrideBufferName[] = "ANGLEVertexAttribOffsetStrideBuffer";

#define MSL_TYPE_ENUM_NAME(TYPE) ("ANGLEVertexAttribType" #TYPE)

void SetFunctionConstant(MTLFunctionConstantValues *funcConstants,
                         const void *data,
                         MTLDataType dataType,
                         const std::string &name)
{
    ANGLE_MTL_OBJC_SCOPE
    {
        NSString *nameObjC = [NSString stringWithUTF8String:name.c_str()];
        [funcConstants setConstantValue:data type:dataType withName:nameObjC];
    }
}

void SetFunctionConstantBool(MTLFunctionConstantValues *funcConstants,
                             BOOL data,
                             const std::string &name)
{
    SetFunctionConstant(funcConstants, &data, MTLDataTypeBool, name);
}

void SetFunctionConstantUInt(MTLFunctionConstantValues *funcConstants,
                             uint32_t data,
                             const std::string &name)
{
    SetFunctionConstant(funcConstants, &data, MTLDataTypeUInt, name);
}

struct VertexAttribute
{
    std::string name;
    std::string typeName;
    int index;
};

enum class FunctionParamType
{
    Unknown,
    StageIn,
    VertexIndex,
    InstanceIndex,
};

struct FunctionParam
{
    FunctionParam() = default;
    FunctionParam(FunctionParam &&src)
        : type(src.type),
          addressSpace(std::move(src.addressSpace)),
          typeName(std::move(src.typeName)),
          name(std::move(src.name)),
          attributes(std::move(src.attributes))
    {
        src.type = FunctionParamType::Unknown;
    }

    FunctionParam &operator=(FunctionParam &&src)
    {
        type         = src.type;
        src.type     = FunctionParamType::Unknown;
        addressSpace = std::move(src.addressSpace);
        typeName     = std::move(src.typeName);
        name         = std::move(src.name);
        attributes   = std::move(src.attributes);

        return *this;
    }

    FunctionParamType type = FunctionParamType::Unknown;
    std::string addressSpace;
    std::string typeName;
    std::string name;
    std::string attributes;
};

bool IsSpace(char c)
{
    return c == ' ' || c == '\t' || c == '\r' || c == '\n';
}

size_t FindNextNonSpace(const std::string &code, size_t idx)
{
    while (idx < code.size() && IsSpace(code[idx]))
    {
        idx++;
    }
    return idx;
}

// Parse entry point's parameters generated by spirv-cross
std::vector<FunctionParam> ParseMslParams(const std::string &code)
{
    enum class ParseState
    {
        NextParam,
        AddressSpaceOrTypeOrClosing,
        Name,
        Attributes,
        Close,
    };

    std::vector<FunctionParam> re;
    size_t idx       = code.find('(') + 1;
    ParseState state = ParseState::NextParam;
    FunctionParam nextParam;
    while (idx < code.size())
    {
        switch (state)
        {
            case ParseState::NextParam:
                if (code[idx] == ',')  // ignore
                {
                    idx++;
                    break;
                }
                nextParam = FunctionParam{};
                idx       = FindNextNonSpace(code, idx);
                state     = ParseState::AddressSpaceOrTypeOrClosing;
                break;
            case ParseState::AddressSpaceOrTypeOrClosing:
                if (code[idx] == ')')
                {
                    state = ParseState::Close;
                }
                else
                {
                    std::string token;
                    do
                    {
                        token += code[idx++];
                    } while (idx < code.size() && !IsSpace(code[idx]));

                    idx = FindNextNonSpace(code, idx);

                    if (token == "device" || token == "constant")
                    {
                        nextParam.addressSpace = std::move(token);
                    }
                    else
                    {
                        while (code[idx] == '*' || code[idx] == '&')
                        {
                            token += code[idx++];
                        }
                        idx                = FindNextNonSpace(code, idx);
                        nextParam.typeName = std::move(token);
                        state              = ParseState::Name;
                    }
                }
                break;
            case ParseState::Name:
            {
                std::string token;
                do
                {
                    token += code[idx++];
                } while (idx < code.size() && !IsSpace(code[idx]) && code[idx] != ',' &&
                         code[idx] != '[' && code[idx] != ')');

                idx = FindNextNonSpace(code, idx);

                nextParam.name = token;

                if (idx == code.size() || code[idx] != '[')
                {
                    re.push_back(std::move(nextParam));
                    state = ParseState::NextParam;
                }
                else
                {
                    state = ParseState::Attributes;
                }
            }
            break;
            case ParseState::Attributes:
            {
                std::string token;
                int bracketBalance = 0;
                do
                {
                    if (code[idx] == '[')
                    {
                        bracketBalance++;
                    }
                    else if (code[idx] == ']')
                    {
                        bracketBalance--;
                    }
                    token += code[idx++];
                } while (idx < code.size() && bracketBalance > 0);
                idx = FindNextNonSpace(code, idx);

                if (token.find("stage_in") != std::string::npos)
                {
                    nextParam.type = FunctionParamType::StageIn;
                }
                else if (token.find("vertex_id") != std::string::npos)
                {
                    nextParam.type = FunctionParamType::VertexIndex;
                }
                if (token.find("instance_id") != std::string::npos)
                {
                    nextParam.type = FunctionParamType::InstanceIndex;
                }

                nextParam.attributes = token;
                re.push_back(std::move(nextParam));
                state = ParseState::NextParam;
            }
            break;
            default:
                idx = code.size();
                break;
        }
    }

    return re;
}

std::vector<VertexAttribute> ParseMslAttributes(const std::string &code)
{
    std::vector<VertexAttribute> re;
    // $1 = type, $2 = name, $3 = attributes
    std::regex attribDeclareRegex(
        R"(([_a-zA-Z0-9<,>]+)\s+([_a-zA-Z0-9<>]+)\s*\[\s*\[\s*attribute\s*\(([0-9]+)\)\s*\]\s*\])");
    std::smatch matchResults;
    std::string::const_iterator ite = code.begin();
    while (ite != code.end() &&
           std::regex_search(ite, code.end(), matchResults, attribDeclareRegex))
    {
        VertexAttribute attrib;
        attrib.typeName             = matchResults[1];
        attrib.name                 = matchResults[2];
        std::string attributeIdxStr = matchResults[3];
        attrib.index                = std::atoi(attributeIdxStr.c_str());

        re.push_back(std::move(attrib));

        ite = matchResults.suffix().first;
    }

    return re;
}

uint32_t GetVertexTypeConstantIdx(uint32_t index)
{
    return kVertexTypeConstBaseIdx + index;
}
uint32_t GetVertexSizeConstantIdx(uint32_t index)
{
    return kVertexSizeConstBaseIdx + index;
}
uint32_t GetVertexDivisorConstantIdx(uint32_t index)
{
    return kVertexDivisorConstBaseIdx + index;
}
uint32_t GetVertexOffsetAlignedConstantIdx(uint32_t index)
{
    return kVertexOffsetAlignedConstBaseIdx + index;
}
uint32_t GetVertexNormalizeConstantIdx(uint32_t index)
{
    return kVertexNormalizeConstBaseIdx + index;
}

std::string GetConstantName(const char *baseName, uint32_t index)
{
    std::ostringstream ss;
    ss << baseName << index;
    return ss.str();
}

std::string GetVertexTypeConstantName(uint32_t index)
{
    return GetConstantName(kVertexTypeConstBaseName, index);
}
std::string GetVertexSizeConstantName(uint32_t index)
{
    return GetConstantName(kVertexSizeConstBaseName, index);
}
std::string GetVertexDivisorConstantName(uint32_t index)
{
    return GetConstantName(kVertexDivisorConstBaseName, index);
}
std::string GetVertexOffsetAlignedConstantName(uint32_t index)
{
    return GetConstantName(kVertexOffsetAlignedConstBaseName, index);
}
std::string GetVertexNormalizeConstantName(uint32_t index)
{
    return GetConstantName(kVertexNormalizeConstBaseName, index);
}

std::string GetVertexBufferNamePrefix(uint32_t index)
{
    std::ostringstream ss;
    ss << kVertexBufferPrefix << index;
    return ss.str();
}

std::ostream &EmitConstantDecl(const std::string &name,
                               uint32_t index,
                               bool isBool,
                               std::ostream *os)
{
    *os << "constant " << (isBool ? "bool " : "uint ") << name << " [[function_constant(" << index
        << ")]];" << std::endl;
    return *os;
}

// Convert glVertexAttribPointer type to shader enum value
uint32_t ConvertVertexTypeToShaderEnumValue(VertexAttributeType componentType)
{
    return static_cast<uint32_t>(componentType);
}

std::ostream &EmitHelperFunctions(std::ostream *os)
{
    *os << R"(
template <typename Short>
static inline Short fetchShortFromBytes(const device uchar *input, uint offset)
{
    Short inputLo = input[offset];
    Short inputHi = input[offset + 1];
    // Little endian conversion:
    return inputLo | (inputHi << 8);
}

template <typename Int>
static inline Int fetchIntFromBytes(const device uchar *input, uint offset)
{
    Int input0 = input[offset];
    Int input1 = input[offset + 1];
    Int input2 = input[offset + 2];
    Int input3 = input[offset + 3];
    // Little endian conversion:
    return input0 | (input1 << 8) | (input2 << 16) | (input3 << 24);
}

template <typename T1, typename T2>
static inline T1 fixedToFloat(T2 fixed)
{
    constexpr float divisor = 1.0 / static_cast<float>(1 << 16);
    return static_cast<T1>(fixed) * divisor;
}

// Copy from src/libANGLE/renderer/copyvertex.inc.h
template <bool isSigned, bool normalized>
static inline float packedXYZ101010ToFloat(uint32_t data)
{
    const uint32_t rgbSignMask  = 0x200;       // 1 set at the 9 bit
    const uint32_t negativeMask = 0xFFFFFC00;  // All bits from 10 to 31 set to 1

    float finalValue = static_cast<float>(data);
    if (isSigned)
    {
        if (data & rgbSignMask)
        {
            int negativeNumber = data | negativeMask;
            finalValue         = static_cast<float>(negativeNumber);
        }

        if (normalized)
        {
            const int32_t maxValue = 0x1FF;       // 1 set in bits 0 through 8
            const int32_t minValue = 0xFFFFFE01;  // Inverse of maxValue

            // A 10-bit two's complement number has the possibility of being minValue - 1 but
            // OpenGL's normalization rules dictate that it should be clamped to minValue in
            // this case.
            if (finalValue < minValue)
            {
                finalValue = minValue;
            }

            const int32_t halfRange = (maxValue - minValue) >> 1;
            finalValue              = ((finalValue - minValue) / halfRange) - 1.0f;
        }
    }
    else
    {
        if (normalized)
        {
            const uint32_t maxValue = 0x3FF;  // 1 set in bits 0 through 9
            finalValue /= static_cast<float>(maxValue);
        }
    }

    return finalValue;
}

template <bool isSigned, bool normalized>
inline float packedW2ToFloat(uint32_t data)
{
    float finalValue = 0;
    if (isSigned)
    {
        if (normalized)
        {
            switch (data)
            {
                case 0x0:
                    finalValue = 0.0f;
                    break;
                case 0x1:
                    finalValue = 1.0f;
                    break;
                case 0x2:
                    finalValue = -1.0f;
                    break;
                case 0x3:
                    finalValue = -1.0f;
                    break;
            }
        }
        else
        {
            switch (data)
            {
                case 0x0:
                    finalValue = 0.0f;
                    break;
                case 0x1:
                    finalValue = 1.0f;
                    break;
                case 0x2:
                    finalValue = -2.0f;
                    break;
                case 0x3:
                    finalValue = -1.0f;
                    break;
            }
        }
    }
    else
    {
        if (normalized)
        {
            finalValue = data / 3.0f;
        }
        else
        {
            finalValue = static_cast<float>(data);
        }
    }

    return finalValue;
}

template <bool isSigned, bool normalized>
static inline float4 packedXYZW1010102ToFloat(uint packedValue)
{
    const uint32_t rgbMask  = 0x3FF;  // 1 set in bits 0 through 9
    const size_t redShift   = 0;      // red is bits 0 through 9
    const size_t greenShift = 10;     // green is bits 10 through 19
    const size_t blueShift  = 20;     // blue is bits 20 through 29

    const uint32_t alphaMask = 0x3;  // 1 set in bits 0 and 1
    const size_t alphaShift  = 30;   // Alpha is the 30 and 31 bits

    float4 re;
    re.x = packedXYZ101010ToFloat<isSigned, normalized>((packedValue >> redShift) & rgbMask);
    re.y = packedXYZ101010ToFloat<isSigned, normalized>((packedValue >> greenShift) & rgbMask);
    re.z = packedXYZ101010ToFloat<isSigned, normalized>((packedValue >> blueShift) & rgbMask);
    re.w = packedW2ToFloat<isSigned, normalized>((packedValue >> alphaShift) & alphaMask);
    return re;
}

template <unsigned int inputBitCount, typename T1, typename T2>
static inline T1 normalizedToFloat(T2 input)
{
    static_assert(inputBitCount <= (sizeof(T2) * 8),
                  "T2 must have more bits than or same bits as inputBitCount.");

    if (inputBitCount < 32) {
        const float inverseMax = 1.0f / (static_cast<uint>(0x1 << inputBitCount) - 1);
        return max(static_cast<T1>(input) * inverseMax, T1(-1.0));
    }
    else {
        constexpr float inverseMax32 = 1.0f / 0xffffffff;
        return max(static_cast<T1>(input) * inverseMax32, T1(-1.0));
    }
}

// uchar
static inline uchar4 fetchUByte(const device uchar *input, int offset, int stride, int index,
                                uint components, uchar defaultAlpha = 1)
{
    uchar4 re = uchar4(0, 0, 0, defaultAlpha);
    for (uint i = 0; i < components; ++i)
    {
        re[i] = input[offset + stride * index + i];
    }
    return re;
}

// uchar normalized
static inline float4 fetchUByteNorm(const device uchar *input, int offset, int stride, int index,
                                    uint components)
{
    uchar4 re = fetchUByte(input, offset, stride, index, components, 255);
    return normalizedToFloat<8, float4>(re);
}

// char
static inline char4 fetchByte(const device uchar *input, int offset, int stride, int index,
                              uint components)
{
    return as_type<char4>(fetchUByte(input, offset, stride, index, components));
}

// char normalized
static inline float4 fetchByteNorm(const device uchar *input, int offset, int stride, int index,
                                   uint components)
{
    char4 re = as_type<char4>(fetchUByte(input, offset, stride, index, components, 127));
    return normalizedToFloat<7, float4>(re);
}

// ushort
static inline ushort4 fetchUShort(const device uchar *input, int offset, int stride, int index,
                                  uint components, ushort defaultAlpha = 1)
{
    ushort4 re = ushort4(0, 0, 0, defaultAlpha);
    for (uint i = 0; i < components; ++i)
    {
        re[i] = fetchShortFromBytes<ushort>(input, offset + stride * index + i * 2);
    }
    return re;
}

// ushort normalized
static inline float4 fetchUShortNorm(const device uchar *input, int offset, int stride, int index,
                                      uint components)
{
    ushort4 re = fetchUShort(input, offset, stride, index, components, 0xffff);
    return normalizedToFloat<16, float4>(re);
}

// short
static inline short4 fetchShort(const device uchar *input, int offset, int stride, int index,
                                uint components)
{
    return as_type<short4>(fetchUShort(input, offset, stride, index, components));
}

// short normalized
static inline float4 fetchShortNorm(const device uchar *input, int offset, int stride, int index,
                                     uint components)
{
    short4 re = as_type<short4>(fetchUShort(input, offset, stride, index, components,
                                            0x7fff));
    return normalizedToFloat<15, float4>(re);
}

// uint
static inline uint4 fetchUInt(const device uchar *input, int offset, int stride, int index,
                              uint components, uint defaultAlpha = 1)
{
    uint4 re = uint4(0, 0, 0, defaultAlpha);
    for (uint i = 0; i < components; ++i)
    {
        re[i] = fetchIntFromBytes<uint>(input, offset + stride * index + i * 4);
    }
    return re;
}

// uint normalized
static inline float4 fetchUIntNorm(const device uchar *input, int offset, int stride, int index,
                                   uint components)
{
    uint4 re = fetchUInt(input, offset, stride, index, components, 0xffffffff);
    return normalizedToFloat<32, float4>(re);
}

// int
static inline int4 fetchInt(const device uchar *input, int offset, int stride, int index,
                            uint components)
{
    return as_type<int4>(fetchUInt(input, offset, stride, index, components));
}

// int normalized
static inline float4 fetchIntNorm(const device uchar *input, int offset, int stride, int index,
                                  uint components)
{
    int4 re = as_type<int4>(fetchUInt(input, offset, stride, index, components,
                                      0x7fffffff));
    return normalizedToFloat<31, float4>(re);
}

// half float
static inline half4 fetchHalf(const device uchar *input, int offset, int stride, int index,
                               uint components)
{
    constexpr half defaultAlpha = 1.0;
    return as_type<half4>(fetchUShort(input, offset, stride, index, components,
                                      as_type<ushort>(defaultAlpha)));
}

// float
static inline float4 fetchFloat(const device uchar *input, int offset, int stride, int index,
                                uint components)
{
    constexpr float defaultAlpha = 1.0;
    return as_type<float4>(fetchUInt(input, offset, stride, index, components,
                                     as_type<uint>(defaultAlpha)));
}

// fixed
static inline float4 fetchFixed(const device uchar *input, int offset, int stride, int index,
                                uint components)
{
    float4 re = float4(0, 0, 0, 1);
    float4 convertedWithPadding = fixedToFloat<float4>(fetchInt(input, offset, stride, index,
                                                                components));
    for (uint i = 0; i < components; ++i)
    {
        re[i] = convertedWithPadding[i];
    }
    return re;
}

// fetch from aligned buffer
// uchar aligned
#define fetchUByte1Aligned(...) fetchUByte(__VA_ARGS__, 1)

static inline uchar4 fetchUByte2Aligned(const device uchar2 *input, int offset, int stride, int index)
{
    uchar4 re;
    re.xy = input[(offset + stride * index) / 2];
    re.z = 0;
    re.w = 1;
    return re;
}
static inline uchar4 fetchUByte3Aligned(const device uchar3 *input, int offset, int stride, int index)
{
    uchar4 re;
    re.xyz = input[(offset + stride * index) / 4];
    re.w = 1;
    return re;
}
static inline uchar4 fetchUByte4Aligned(const device uchar4 *input, int offset, int stride, int index)
{
    uchar4 re;
    re = input[(offset + stride * index) / 4];
    return re;
}

// uchar aligned + normalized
#define fetchUByte1AlignedNorm(...) fetchUByteNorm(__VA_ARGS__, 1)

static inline float4 fetchUByte2AlignedNorm(const device uchar2 *input, int offset, int stride, int index)
{
    uchar4 re = fetchUByte2Aligned(input, offset, stride, index);
    re.w = 0xff;
    return normalizedToFloat<8, float4>(re);
}
static inline float4 fetchUByte3AlignedNorm(const device uchar3 *input, int offset, int stride, int index)
{
    uchar4 re = fetchUByte3Aligned(input, offset, stride, index);
    re.w = 0xff;
    return normalizedToFloat<8, float4>(re);
}
static inline float4 fetchUByte4AlignedNorm(const device uchar4 *input, int offset, int stride, int index)
{
    uchar4 re = fetchUByte4Aligned(input, offset, stride, index);
    return normalizedToFloat<8, float4>(re);
}

// char aligned
#define fetchByte1Aligned(...) fetchByte(__VA_ARGS__, 1)

static inline char4 fetchByte2Aligned(const device uchar2 *input, int offset, int stride, int index)
{
    return as_type<char4>(fetchUByte2Aligned(input, offset, stride, index));
}
static inline char4 fetchByte3Aligned(const device uchar3 *input, int offset, int stride, int index)
{
    return as_type<char4>(fetchUByte3Aligned(input, offset, stride, index));
}
static inline char4 fetchByte4Aligned(const device uchar4 *input, int offset, int stride, int index)
{
    return as_type<char4>(fetchUByte4Aligned(input, offset, stride, index));
}

// char aligned + normalized
#define fetchByte1AlignedNorm(...) fetchByteNorm(__VA_ARGS__, 1)

static inline float4 fetchByte2AlignedNorm(const device uchar2 *input, int offset, int stride, int index)
{
    char4 re = as_type<char4>(fetchUByte2Aligned(input, offset, stride, index));
    re.w = 0x7f;
    return normalizedToFloat<7, float4>(re);
}
static inline float4 fetchByte3AlignedNorm(const device uchar3 *input, int offset, int stride, int index)
{
    char4 re = as_type<char4>(fetchUByte3Aligned(input, offset, stride, index));
    re.w = 0x7f;
    return normalizedToFloat<7, float4>(re);
}
static inline float4 fetchByte4AlignedNorm(const device uchar4 *input, int offset, int stride, int index)
{
    char4 re = as_type<char4>(fetchUByte4Aligned(input, offset, stride, index));
    return normalizedToFloat<7, float4>(re);
}

// ushort aligned
static inline ushort4 fetchUShort1Aligned(const device ushort *input, int offset, int stride, int index)
{
    ushort4 re;
    re.x = input[(offset + stride * index) / 2];
    re.y = 0;
    re.z = 0;
    re.w = 1;
    return re;
}
static inline ushort4 fetchUShort2Aligned(const device ushort2 *input, int offset, int stride, int index)
{
    ushort4 re;
    re.xy = input[(offset + stride * index) / 4];
    re.z = 0;
    re.w = 1;
    return re;
}
static inline ushort4 fetchUShort3Aligned(const device ushort3 *input, int offset, int stride, int index)
{
    ushort4 re;
    re.xyz = input[(offset + stride * index) / 8];
    re.w = 1;
    return re;
}
static inline ushort4 fetchUShort4Aligned(const device ushort4 *input, int offset, int stride, int index)
{
    ushort4 re;
    re = input[(offset + stride * index) / 8];
    return re;
}

// ushort aligned + normalized
static inline float4 fetchUShort1AlignedNorm(const device ushort *input, int offset, int stride, int index)
{
    ushort4 re = fetchUShort1Aligned(input, offset, stride, index);
    return float4(normalizedToFloat<16, float3>(re.xyz), 1.0);
}
static inline float4 fetchUShort2AlignedNorm(const device ushort2 *input, int offset, int stride, int index)
{
    ushort4 re = fetchUShort2Aligned(input, offset, stride, index);
    return float4(normalizedToFloat<16, float3>(re.xyz), 1.0);
}
static inline float4 fetchUShort3AlignedNorm(const device ushort3 *input, int offset, int stride, int index)
{
    ushort4 re = fetchUShort3Aligned(input, offset, stride, index);
    return float4(normalizedToFloat<16, float3>(re.xyz), 1.0);
}
static inline float4 fetchUShort4AlignedNorm(const device ushort4 *input, int offset, int stride, int index)
{
    ushort4 re = fetchUShort4Aligned(input, offset, stride, index);
    return normalizedToFloat<16, float4>(re);
}

// short aligned
static inline short4 fetchShort1Aligned(const device ushort *input, int offset, int stride, int index)
{
    return as_type<short4>(fetchUShort1Aligned(input, offset, stride, index));
}
static inline short4 fetchShort2Aligned(const device ushort2 *input, int offset, int stride, int index)
{
    return as_type<short4>(fetchUShort2Aligned(input, offset, stride, index));
}
static inline short4 fetchShort3Aligned(const device ushort3 *input, int offset, int stride, int index)
{
    return as_type<short4>(fetchUShort3Aligned(input, offset, stride, index));
}
static inline short4 fetchShort4Aligned(const device ushort4 *input, int offset, int stride, int index)
{
    return as_type<short4>(fetchUShort4Aligned(input, offset, stride, index));
}

// short aligned + normalized
static inline float4 fetchShort1AlignedNorm(const device ushort *input, int offset, int stride, int index)
{
    short4 re = as_type<short4>(fetchUShort1Aligned(input, offset, stride, index));
    return float4(normalizedToFloat<15, float3>(re.xyz), 1.0);
}
static inline float4 fetchShort2AlignedNorm(const device ushort2 *input, int offset, int stride, int index)
{
    short4 re = as_type<short4>(fetchUShort2Aligned(input, offset, stride, index));
    return float4(normalizedToFloat<15, float3>(re.xyz), 1.0);
}
static inline float4 fetchShort3AlignedNorm(const device ushort3 *input, int offset, int stride, int index)
{
    short4 re = as_type<short4>(fetchUShort3Aligned(input, offset, stride, index));
    return float4(normalizedToFloat<15, float3>(re.xyz), 1.0);
}
static inline float4 fetchShort4AlignedNorm(const device ushort4 *input, int offset, int stride, int index)
{
    short4 re = as_type<short4>(fetchUShort4Aligned(input, offset, stride, index));
    return normalizedToFloat<15, float4>(re);
}

// uint aligned
static inline uint4 fetchUInt1Aligned(const device uint *input, int offset, int stride, int index)
{
    uint4 re;
    re.x = input[(offset + stride * index) / 4];
    re.y = 0;
    re.z = 0;
    re.w = 1;
    return re;
}

static inline uint4 fetchUInt2Aligned(const device uint2 *input, int offset, int stride, int index)
{
    uint4 re;
    re.xy = input[(offset + stride * index) / 8];
    re.z = 0;
    re.w = 1;
    return re;
}

static inline uint4 fetchUInt3Aligned(const device uint3 *input, int offset, int stride, int index)
{
    uint4 re;
    re.xyz = input[(offset + stride * index) / 16];
    re.w = 1;
    return re;
}
static inline uint4 fetchUInt4Aligned(const device uint4 *input, int offset, int stride, int index)
{
    uint4 re;
    re = input[(offset + stride * index) / 16];
    return re;
}

// uint aligned normalized
static inline float4 fetchUInt1AlignedNorm(const device uint *input, int offset, int stride, int index)
{
    uint4 re = fetchUInt1Aligned(input, offset, stride, index);
    return float4(normalizedToFloat<32, float3>(re.xyz), 1.0);
}
static inline float4 fetchUInt2AlignedNorm(const device uint2 *input, int offset, int stride, int index)
{
    uint4 re = fetchUInt2Aligned(input, offset, stride, index);
    return float4(normalizedToFloat<32, float3>(re.xyz), 1.0);
}
static inline float4 fetchUInt3AlignedNorm(const device uint3 *input, int offset, int stride, int index)
{
    uint4 re = fetchUInt3Aligned(input, offset, stride, index);
    return float4(normalizedToFloat<32, float3>(re.xyz), 1.0);
}
static inline float4 fetchUInt4AlignedNorm(const device uint4 *input, int offset, int stride, int index)
{
    uint4 re = fetchUInt4Aligned(input, offset, stride, index);
    return normalizedToFloat<32, float4>(re);
}

// int aligned
static inline int4 fetchInt1Aligned(const device uint *input, int offset, int stride, int index)
{
    return as_type<int4>(fetchUInt1Aligned(input, offset, stride, index));
}
static inline int4 fetchInt2Aligned(const device uint2 *input, int offset, int stride, int index)
{
    return as_type<int4>(fetchUInt2Aligned(input, offset, stride, index));
}
static inline int4 fetchInt3Aligned(const device uint3 *input, int offset, int stride, int index)
{
    return as_type<int4>(fetchUInt3Aligned(input, offset, stride, index));
}
static inline int4 fetchInt4Aligned(const device uint4 *input, int offset, int stride, int index)
{
    return as_type<int4>(fetchUInt4Aligned(input, offset, stride, index));
}

// int aligned + normalized
static inline float4 fetchInt1AlignedNorm(const device uint *input, int offset, int stride, int index)
{
    int4 re = as_type<int4>(fetchUInt1Aligned(input, offset, stride, index));
    return float4(normalizedToFloat<31, float3>(re.xyz), 1.0);
}
static inline float4 fetchInt2AlignedNorm(const device uint2 *input, int offset, int stride, int index)
{
    int4 re = as_type<int4>(fetchUInt2Aligned(input, offset, stride, index));
    return float4(normalizedToFloat<31, float3>(re.xyz), 1.0);
}
static inline float4 fetchInt3AlignedNorm(const device uint3 *input, int offset, int stride, int index)
{
    int4 re = as_type<int4>(fetchUInt3Aligned(input, offset, stride, index));
    return float4(normalizedToFloat<31, float3>(re.xyz), 1.0);
}
static inline float4 fetchInt4AlignedNorm(const device uint4 *input, int offset, int stride, int index)
{
    int4 re = as_type<int4>(fetchUInt4Aligned(input, offset, stride, index));
    return normalizedToFloat<31, float4>(re);
}

// half float aligned
static inline half4 fetchHalf1Aligned(const device ushort *input, int offset, int stride, int index)
{
    auto re = as_type<half4>(fetchUShort1Aligned(input, offset, stride, index));
    re.w = 1.0;
    return re;
}
static inline half4 fetchHalf2Aligned(const device ushort2 *input, int offset, int stride, int index)
{
    auto re = as_type<half4>(fetchUShort2Aligned(input, offset, stride, index));
    re.w = 1.0;
    return re;
}
static inline half4 fetchHalf3Aligned(const device ushort3 *input, int offset, int stride, int index)
{
    auto re = as_type<half4>(fetchUShort3Aligned(input, offset, stride, index));
    re.w = 1.0;
    return re;
}
static inline half4 fetchHalf4Aligned(const device ushort4 *input, int offset, int stride, int index)
{
    return as_type<half4>(fetchUShort4Aligned(input, offset, stride, index));
}

// float aligned
static inline float4 fetchFloat1Aligned(const device uint *input, int offset, int stride, int index)
{
    auto re = as_type<float4>(fetchUInt1Aligned(input, offset, stride, index));
    re.w = 1.0;
    return re;
}
static inline float4 fetchFloat2Aligned(const device uint2 *input, int offset, int stride, int index)
{
    auto re = as_type<float4>(fetchUInt2Aligned(input, offset, stride, index));
    re.w = 1.0;
    return re;
}
static inline float4 fetchFloat3Aligned(const device uint3 *input, int offset, int stride, int index)
{
    auto re = as_type<float4>(fetchUInt3Aligned(input, offset, stride, index));
    re.w = 1.0;
    return re;
}
static inline float4 fetchFloat4Aligned(const device uint4 *input, int offset, int stride, int index)
{
    return as_type<float4>(fetchUInt4Aligned(input, offset, stride, index));
}

// fixed aligned
static inline float4 fetchFixed1Aligned(const device uint *input, int offset, int stride, int index)
{
    float4 re;
    re.x = fixedToFloat<float>(fetchInt1Aligned(input, offset, stride, index).x);
    re.y = 0;
    re.z = 0;
    re.w = 1;
    return re;
}
static inline float4 fetchFixed2Aligned(const device uint2 *input, int offset, int stride, int index)
{
    float4 re;
    re.xy = fixedToFloat<float2>(fetchInt2Aligned(input, offset, stride, index).xy);
    re.z = 0;
    re.w = 1;
    return re;
}
static inline float4 fetchFixed3Aligned(const device uint3 *input, int offset, int stride, int index)
{
    float4 re;
    re.xyz = fixedToFloat<float3>(fetchInt3Aligned(input, offset, stride, index).xyz);
    re.w = 1;
    return re;
}
static inline float4 fetchFixed4Aligned(const device uint4 *input, int offset, int stride, int index)
{
    float4 re;
    re = fixedToFloat<float4>(fetchInt4Aligned(input, offset, stride, index));
    return re;
}

// packed XYZW1010102
template <bool isSigned, bool normalized>
static inline float4 fetchPackedXYZW1010102(const device uchar *input, int offset, int stride, int index)
{
    uint packedValue = fetchIntFromBytes<uint>(input, offset + stride * index);
    return packedXYZW1010102ToFloat<isSigned, normalized>(packedValue);
}

template <bool isSigned, bool normalized>
static inline float4 fetchPackedXYZW1010102(const device uchar *input, int offset, int stride, int index,
                                            int components /* ignored */)
{
    return fetchPackedXYZW1010102<isSigned, normalized>(input, offset, stride, index);
}

template <bool isSigned, bool normalized>
static inline float4 fetchPackedXYZW1010102Aligned(const device uint *input, int offset, int stride,
                                                   int index)
{
    uint packedValue = input[(offset + stride * index) / 4];
    return packedXYZW1010102ToFloat<isSigned, normalized>(packedValue);
}

#define fetchXYZW1010102Int                fetchPackedXYZW1010102<true, false>
#define fetchXYZW1010102IntNorm            fetchPackedXYZW1010102<true, true>
#define fetchXYZW1010102IntAligned         fetchPackedXYZW1010102Aligned<true, false>
#define fetchXYZW1010102IntAlignedNorm     fetchPackedXYZW1010102Aligned<true, true>

#define fetchXYZW1010102UInt                fetchPackedXYZW1010102<false, false>
#define fetchXYZW1010102UIntNorm            fetchPackedXYZW1010102<false, true>
#define fetchXYZW1010102UIntAligned         fetchPackedXYZW1010102Aligned<false, false>
#define fetchXYZW1010102UIntAlignedNorm     fetchPackedXYZW1010102Aligned<false, true>

// Cast to float
template <typename Vec4>
static inline float4 castTo(Vec4 src, float4)
{
    return static_cast<float4>(src);
}

template <typename Vec4>
static inline float3 castTo(Vec4 src, float3)
{
    return static_cast<float3>(src.xyz);
}

template <typename Vec4>
static inline float2 castTo(Vec4 src, float2)
{
    return static_cast<float2>(src.xy);
}

template <typename Vec4>
static inline float castTo(Vec4 src, float)
{
    return static_cast<float>(src.x);
}

// cast to int
template <typename Vec4>
static inline int4 castTo(Vec4 src, int4)
{
    return static_cast<int4>(src);
}

template <typename Vec4>
static inline int3 castTo(Vec4 src, int3)
{
    return static_cast<int3>(src.xyz);
}

template <typename Vec4>
static inline int2 castTo(Vec4 src, int2)
{
    return static_cast<int2>(src.xy);
}

template <typename Vec4>
static inline int castTo(Vec4 src, int)
{
    return static_cast<int>(src.x);
}

// cast to uint
template <typename Vec4>
static inline uint4 castTo(Vec4 src, uint4)
{
    return static_cast<uint4>(src);
}

template <typename Vec4>
static inline uint3 castTo(Vec4 src, uint3)
{
    return static_cast<uint3>(src.xyz);
}

template <typename Vec4>
static inline uint2 castTo(Vec4 src, uint2)
{
    return static_cast<uint2>(src.xy);
}

template <typename Vec4>
static inline uint castTo(Vec4 src, uint)
{
    return static_cast<uint>(src.x);
}

// COMP_NUMBER = number of components, must be literal
#define FETCH_ALIGNED(TYPE, COMP_NUMBER, INPUT, OFFSET, STRIDE, INDEX) \
    fetch##TYPE##COMP_NUMBER##Aligned(INPUT, OFFSET, STRIDE, INDEX)

#define FETCH_ALIGNED_NORM(TYPE, COMP_NUMBER, INPUT, OFFSET, STRIDE, INDEX) \
    fetch##TYPE##COMP_NUMBER##AlignedNorm(INPUT, OFFSET, STRIDE, INDEX)

// COMP_VAR = number of components, can be expression, variable, number, etc.
#define FETCH_UNALIGNED(TYPE, COMP_VAR, INPUT, OFFSET, STRIDE, INDEX) \
    fetch##TYPE(INPUT, OFFSET, STRIDE, INDEX, COMP_VAR)

#define FETCH_UNALIGNED_NORM(TYPE, COMP_VAR, INPUT, OFFSET, STRIDE, INDEX) \
    fetch##TYPE##Norm(INPUT, OFFSET, STRIDE, INDEX, COMP_VAR)

#define FETCH_ALIGNED_INT(TYPE, COMP_NUMBER, INPUT, OFFSET, STRIDE, INDEX, NORM, DEST)            \
    if (NORM)                                                                                     \
    {                                                                                             \
        DEST = castTo(FETCH_ALIGNED_NORM(TYPE, COMP_NUMBER, INPUT, OFFSET, STRIDE, INDEX), DEST); \
    }                                                                                             \
    else                                                                                          \
    {                                                                                             \
        DEST = castTo(FETCH_ALIGNED(TYPE, COMP_NUMBER, INPUT, OFFSET, STRIDE, INDEX), DEST);      \
    }

#define FETCH_UNALIGNED_INT(TYPE, COMP_VAR, INPUT, OFFSET, STRIDE, INDEX, NORM, DEST)            \
    if (NORM)                                                                                    \
    {                                                                                            \
        DEST = castTo(FETCH_UNALIGNED_NORM(TYPE, COMP_VAR, INPUT, OFFSET, STRIDE, INDEX), DEST); \
    }                                                                                            \
    else                                                                                         \
    {                                                                                            \
        DEST = castTo(FETCH_UNALIGNED(TYPE, COMP_VAR, INPUT, OFFSET, STRIDE, INDEX), DEST);      \
    }

#define FETCH_ALIGNED_FLOAT(TYPE, COMP_NUMBER, INPUT, OFFSET, STRIDE, INDEX, NORM, DEST) \
    DEST = castTo(FETCH_ALIGNED(TYPE, COMP_NUMBER, INPUT, OFFSET, STRIDE, INDEX), DEST);

#define FETCH_UNALIGNED_FLOAT(TYPE, COMP_VAR, INPUT, OFFSET, STRIDE, INDEX, NORM, DEST) \
    DEST = castTo(FETCH_UNALIGNED(TYPE, COMP_VAR, INPUT, OFFSET, STRIDE, INDEX), DEST);

#define FETCH_CASE(TYPE, COMP_VAR, ALIGNED_INPUT_PREFIX, UNALIGNED_INPUT, OFFSET, STRIDE, INDEX, \
                   NORM, ALIGNED, FETCH_ALIGNED_PROC, FETCH_UNALIGNED_PROC, DEST)                \
    case ANGLEVertexAttribType##TYPE:                                                            \
        if (ALIGNED)                                                                             \
        {                                                                                        \
            switch (COMP_VAR)                                                                    \
            {                                                                                    \
                case 1:                                                                          \
                    FETCH_ALIGNED_PROC(TYPE, 1, ALIGNED_INPUT_PREFIX##1, OFFSET, STRIDE, INDEX,  \
                                       NORM, DEST);                                              \
                    break;                                                                       \
                case 2:                                                                          \
                    FETCH_ALIGNED_PROC(TYPE, 2, ALIGNED_INPUT_PREFIX##2, OFFSET, STRIDE, INDEX,  \
                                       NORM, DEST);                                              \
                    break;                                                                       \
                case 3:                                                                          \
                    FETCH_ALIGNED_PROC(TYPE, 3, ALIGNED_INPUT_PREFIX##3, OFFSET, STRIDE, INDEX,  \
                                       NORM, DEST);                                              \
                    break;                                                                       \
                case 4:                                                                          \
                    FETCH_ALIGNED_PROC(TYPE, 4, ALIGNED_INPUT_PREFIX##4, OFFSET, STRIDE, INDEX,  \
                                       NORM, DEST);                                              \
                    break;                                                                       \
            }                                                                                    \
        }                                                                                        \
        else                                                                                     \
        {                                                                                        \
            FETCH_UNALIGNED_PROC(TYPE, COMP_VAR, UNALIGNED_INPUT, OFFSET, STRIDE, INDEX, NORM,   \
                                 DEST)                                                           \
        }                                                                                        \
        break;

#define FETCH_CASE_PACKED(TYPE, ALIGNED_INPUT_PREFIX, UNALIGNED_INPUT, OFFSET, STRIDE, INDEX,      \
                          NORM, ALIGNED, DEST)                                                     \
    case ANGLEVertexAttribType##TYPE:                                                              \
        if (ALIGNED)                                                                               \
        {                                                                                          \
            FETCH_ALIGNED_INT(TYPE, , ALIGNED_INPUT_PREFIX##1, OFFSET, STRIDE, INDEX, NORM, DEST); \
        }                                                                                          \
        else                                                                                       \
        {                                                                                          \
            FETCH_UNALIGNED_INT(TYPE, 0, UNALIGNED_INPUT, OFFSET, STRIDE, INDEX, NORM, DEST)       \
        }                                                                                          \
        break;

#define FETCH_CASE_INT(TYPE, COMP_VAR, ALIGNED_INPUT_PREFIX, UNALIGNED_INPUT, OFFSET, STRIDE,      \
                       INDEX, NORM, ALIGNED, DEST)                                                 \
    FETCH_CASE(TYPE, COMP_VAR, ALIGNED_INPUT_PREFIX, UNALIGNED_INPUT, OFFSET, STRIDE, INDEX, NORM, \
               ALIGNED, FETCH_ALIGNED_INT, FETCH_UNALIGNED_INT, DEST)

#define FETCH_CASE_FLOAT(TYPE, COMP_VAR, ALIGNED_INPUT_PREFIX, UNALIGNED_INPUT, OFFSET, STRIDE,    \
                         INDEX, NORM, ALIGNED, DEST)                                               \
    FETCH_CASE(TYPE, COMP_VAR, ALIGNED_INPUT_PREFIX, UNALIGNED_INPUT, OFFSET, STRIDE, INDEX, NORM, \
               ALIGNED, FETCH_ALIGNED_FLOAT, FETCH_UNALIGNED_FLOAT, DEST)

#define FETCH_CODE(TYPE_VAR, COMP_VAR, INPUT_PREFIX, OFFSET, STRIDE, NORM, ALIGNED, DIVISOR, DEST) \
    {                                                                                              \
        uint vertexFinalIndex;                                                                     \
        if ((DIVISOR) == 0)                                                                        \
        {                                                                                          \
            vertexFinalIndex = gl_VertexIndex;                                                     \
        }                                                                                          \
        else                                                                                       \
        {                                                                                          \
            vertexFinalIndex = gl_InstanceIndex / (DIVISOR);                                       \
        }                                                                                          \
        switch (TYPE_VAR)                                                                          \
        {                                                                                          \
            FETCH_CASE_INT(Byte, COMP_VAR, INPUT_PREFIX##AsByte, INPUT_PREFIX##AsByte1, OFFSET,    \
                           STRIDE, vertexFinalIndex, NORM, ALIGNED, DEST)                          \
            FETCH_CASE_INT(UByte, COMP_VAR, INPUT_PREFIX##AsByte, INPUT_PREFIX##AsByte1, OFFSET,   \
                           STRIDE, vertexFinalIndex, NORM, ALIGNED, DEST)                          \
            FETCH_CASE_INT(Short, COMP_VAR, INPUT_PREFIX##AsShort, INPUT_PREFIX##AsByte1, OFFSET,  \
                           STRIDE, vertexFinalIndex, NORM, ALIGNED, DEST)                          \
            FETCH_CASE_INT(UShort, COMP_VAR, INPUT_PREFIX##AsShort, INPUT_PREFIX##AsByte1, OFFSET, \
                           STRIDE, vertexFinalIndex, NORM, ALIGNED, DEST)                          \
            FETCH_CASE_INT(Int, COMP_VAR, INPUT_PREFIX##AsInt, INPUT_PREFIX##AsByte1, OFFSET,      \
                           STRIDE, vertexFinalIndex, NORM, ALIGNED, DEST)                          \
            FETCH_CASE_INT(UInt, COMP_VAR, INPUT_PREFIX##AsInt, INPUT_PREFIX##AsByte1, OFFSET,     \
                           STRIDE, vertexFinalIndex, NORM, ALIGNED, DEST)                          \
                                                                                                   \
            FETCH_CASE_PACKED(XYZW1010102Int, INPUT_PREFIX##AsInt, INPUT_PREFIX##AsByte1, OFFSET,  \
                              STRIDE, vertexFinalIndex, NORM, ALIGNED, DEST)                       \
            FETCH_CASE_PACKED(XYZW1010102UInt, INPUT_PREFIX##AsInt, INPUT_PREFIX##AsByte1, OFFSET, \
                              STRIDE, vertexFinalIndex, NORM, ALIGNED, DEST)                       \
                                                                                                   \
            FETCH_CASE_FLOAT(Float, COMP_VAR, INPUT_PREFIX##AsInt, INPUT_PREFIX##AsByte1, OFFSET,  \
                             STRIDE, vertexFinalIndex, NORM, ALIGNED, DEST)                        \
            FETCH_CASE_FLOAT(Half, COMP_VAR, INPUT_PREFIX##AsShort, INPUT_PREFIX##AsByte1, OFFSET, \
                             STRIDE, vertexFinalIndex, NORM, ALIGNED, DEST)                        \
            FETCH_CASE_FLOAT(Fixed, COMP_VAR, INPUT_PREFIX##AsInt, INPUT_PREFIX##AsByte1, OFFSET,  \
                             STRIDE, vertexFinalIndex, NORM, ALIGNED, DEST)                        \
                                                                                                   \
            break;                                                                                 \
        }                                                                                          \
    }

)";
    return *os;
}

std::ostream &EmitConstantsDecls(const std::vector<VertexAttribute> &attribs, std::ostream *os)
{
#define DECLARE_TYPE_CONST(CONST_NAME, TYPE)                                                  \
    *os << "constant int " << CONST_NAME << " = " << ConvertVertexTypeToShaderEnumValue(TYPE) \
        << ";\n"

    DECLARE_TYPE_CONST(MSL_TYPE_ENUM_NAME(Float), VertexAttributeType::Float);
    DECLARE_TYPE_CONST(MSL_TYPE_ENUM_NAME(Fixed), VertexAttributeType::Fixed);
    DECLARE_TYPE_CONST(MSL_TYPE_ENUM_NAME(XYZW1010102Int), VertexAttributeType::XYZW1010102Int);
    DECLARE_TYPE_CONST(MSL_TYPE_ENUM_NAME(XYZW1010102UInt), VertexAttributeType::XYZW1010102UInt);
    DECLARE_TYPE_CONST(MSL_TYPE_ENUM_NAME(Byte), VertexAttributeType::Byte);
    DECLARE_TYPE_CONST(MSL_TYPE_ENUM_NAME(UByte), VertexAttributeType::UByte);
    DECLARE_TYPE_CONST(MSL_TYPE_ENUM_NAME(Short), VertexAttributeType::Short);
    DECLARE_TYPE_CONST(MSL_TYPE_ENUM_NAME(UShort), VertexAttributeType::UShort);
    DECLARE_TYPE_CONST(MSL_TYPE_ENUM_NAME(Int), VertexAttributeType::Int);
    DECLARE_TYPE_CONST(MSL_TYPE_ENUM_NAME(UInt), VertexAttributeType::UInt);
    DECLARE_TYPE_CONST(MSL_TYPE_ENUM_NAME(Half), VertexAttributeType::Half);

    for (const VertexAttribute &attrib : attribs)
    {
        EmitConstantDecl(GetVertexTypeConstantName(attrib.index),
                         GetVertexTypeConstantIdx(attrib.index), false, os);
        EmitConstantDecl(GetVertexSizeConstantName(attrib.index),
                         GetVertexSizeConstantIdx(attrib.index), false, os);
        EmitConstantDecl(GetVertexDivisorConstantName(attrib.index),
                         GetVertexDivisorConstantIdx(attrib.index), false, os);
        EmitConstantDecl(GetVertexNormalizeConstantName(attrib.index),
                         GetVertexNormalizeConstantIdx(attrib.index), true, os);
        EmitConstantDecl(GetVertexOffsetAlignedConstantName(attrib.index),
                         GetVertexOffsetAlignedConstantIdx(attrib.index), true, os);

        // constant indicating the format is packed
        *os << "constant bool ANGLEVertexAttribIsPacked32Bit_" << attrib.index << " = "
            << GetVertexTypeConstantName(attrib.index)
            << " == " << MSL_TYPE_ENUM_NAME(XYZW1010102Int) << " || "
            << GetVertexTypeConstantName(attrib.index)
            << " == " << MSL_TYPE_ENUM_NAME(XYZW1010102UInt) << ";" << std::endl;

        // constants based on num components
        *os << "constant bool ANGLEVertexAttribSizeIs1_" << attrib.index << " = "
            << GetVertexSizeConstantName(attrib.index) << " == 1;" << std::endl;
        *os << "constant bool ANGLEVertexAttribSizeIs2_" << attrib.index << " = "
            << GetVertexSizeConstantName(attrib.index) << " == 2;" << std::endl;
        *os << "constant bool ANGLEVertexAttribSizeIs3_" << attrib.index << " = "
            << GetVertexSizeConstantName(attrib.index) << " == 3;" << std::endl;
        *os << "constant bool ANGLEVertexAttribSizeIs4_" << attrib.index << " = "
            << GetVertexSizeConstantName(attrib.index) << " == 4;" << std::endl;

        // constants based on component's size (bytes)
        *os << "constant bool ANGLEVertexAttribIs4Bytes" << attrib.index << " = "
            << GetVertexTypeConstantName(attrib.index) << " == " << MSL_TYPE_ENUM_NAME(Float)
            << " || " << GetVertexTypeConstantName(attrib.index)
            << " == " << MSL_TYPE_ENUM_NAME(Fixed) << " || "
            << GetVertexTypeConstantName(attrib.index) << " == " << MSL_TYPE_ENUM_NAME(Int)
            << " || " << GetVertexTypeConstantName(attrib.index)
            << " == " << MSL_TYPE_ENUM_NAME(UInt) << " || ANGLEVertexAttribIsPacked32Bit_"
            << attrib.index << ";" << std::endl;

        *os << "constant bool ANGLEVertexAttribIs2Bytes" << attrib.index << " = "
            << GetVertexTypeConstantName(attrib.index) << " == " << MSL_TYPE_ENUM_NAME(Half)
            << " || " << GetVertexTypeConstantName(attrib.index)
            << " == " << MSL_TYPE_ENUM_NAME(Short) << " || "
            << GetVertexTypeConstantName(attrib.index) << " == " << MSL_TYPE_ENUM_NAME(UShort)
            << ";" << std::endl;

        *os << "constant bool ANGLEVertexAttribIs1Bytes" << attrib.index << " = "
            << GetVertexTypeConstantName(attrib.index) << " == " << MSL_TYPE_ENUM_NAME(Byte)
            << " || " << GetVertexTypeConstantName(attrib.index)
            << " == " << MSL_TYPE_ENUM_NAME(UByte) << ";" << std::endl;

        // constants based on source buffer's aligned typeless type
        *os << "constant bool ANGLEVertexAttribSrcUChar2_" << attrib.index << " = "
            << GetVertexOffsetAlignedConstantName(attrib.index) << " && "
            << "ANGLEVertexAttribIs1Bytes" << attrib.index << " && "
            << "ANGLEVertexAttribSizeIs2_" << attrib.index << ";" << std::endl;

        *os << "constant bool ANGLEVertexAttribSrcUChar3_" << attrib.index << " = "
            << GetVertexOffsetAlignedConstantName(attrib.index) << " && "
            << "ANGLEVertexAttribIs1Bytes" << attrib.index << " && "
            << "ANGLEVertexAttribSizeIs3_" << attrib.index << ";" << std::endl;

        *os << "constant bool ANGLEVertexAttribSrcUChar4_" << attrib.index << " = "
            << GetVertexOffsetAlignedConstantName(attrib.index) << " && "
            << "ANGLEVertexAttribIs1Bytes" << attrib.index << " && "
            << "ANGLEVertexAttribSizeIs4_" << attrib.index << ";" << std::endl;

        *os << "constant bool ANGLEVertexAttribSrcUShort1_" << attrib.index << " = "
            << GetVertexOffsetAlignedConstantName(attrib.index) << " && "
            << "ANGLEVertexAttribIs2Bytes" << attrib.index << " && "
            << "ANGLEVertexAttribSizeIs1_" << attrib.index << ";" << std::endl;

        *os << "constant bool ANGLEVertexAttribSrcUShort2_" << attrib.index << " = "
            << GetVertexOffsetAlignedConstantName(attrib.index) << " && "
            << "ANGLEVertexAttribIs2Bytes" << attrib.index << " && "
            << "ANGLEVertexAttribSizeIs2_" << attrib.index << ";" << std::endl;

        *os << "constant bool ANGLEVertexAttribSrcUShort3_" << attrib.index << " = "
            << GetVertexOffsetAlignedConstantName(attrib.index) << " && "
            << "ANGLEVertexAttribIs2Bytes" << attrib.index << " && "
            << "ANGLEVertexAttribSizeIs3_" << attrib.index << ";" << std::endl;

        *os << "constant bool ANGLEVertexAttribSrcUShort4_" << attrib.index << " = "
            << GetVertexOffsetAlignedConstantName(attrib.index) << " && "
            << "ANGLEVertexAttribIs2Bytes" << attrib.index << " && "
            << "ANGLEVertexAttribSizeIs4_" << attrib.index << ";" << std::endl;

        *os << "constant bool ANGLEVertexAttribSrcUInt1_" << attrib.index << " = "
            << GetVertexOffsetAlignedConstantName(attrib.index) << " && "
            << "ANGLEVertexAttribIs4Bytes" << attrib.index << " && "
            << "(ANGLEVertexAttribSizeIs1_" << attrib.index << " || ANGLEVertexAttribIsPacked32Bit_"
            << attrib.index << ");" << std::endl;

        *os << "constant bool ANGLEVertexAttribSrcUInt2_" << attrib.index << " = "
            << GetVertexOffsetAlignedConstantName(attrib.index) << " && "
            << "ANGLEVertexAttribIs4Bytes" << attrib.index << " && "
            << "(ANGLEVertexAttribSizeIs2_" << attrib.index
            << " && !ANGLEVertexAttribIsPacked32Bit_" << attrib.index << ");" << std::endl;

        *os << "constant bool ANGLEVertexAttribSrcUInt3_" << attrib.index << " = "
            << GetVertexOffsetAlignedConstantName(attrib.index) << " && "
            << "ANGLEVertexAttribIs4Bytes" << attrib.index << " && "
            << "(ANGLEVertexAttribSizeIs3_" << attrib.index
            << " && !ANGLEVertexAttribIsPacked32Bit_" << attrib.index << ");" << std::endl;

        *os << "constant bool ANGLEVertexAttribSrcUInt4_" << attrib.index << " = "
            << GetVertexOffsetAlignedConstantName(attrib.index) << " && "
            << "ANGLEVertexAttribIs4Bytes" << attrib.index << " && "
            << "(ANGLEVertexAttribSizeIs4_" << attrib.index
            << " && !ANGLEVertexAttribIsPacked32Bit_" << attrib.index << ");" << std::endl;

        // Unaligned flag
        *os << "constant bool ANGLEVertexAttribIsUnaligned" << attrib.index << " = "
            << "!" << GetVertexOffsetAlignedConstantName(attrib.index) << ";" << std::endl;
    }

    return *os;
}

std::ostream &EmitVertexFetchCodeEntryPrototype(const std::string &desiredEntryName,
                                                const std::string &returnType,
                                                const std::vector<FunctionParam> &params,
                                                const std::vector<VertexAttribute> &attribs,
                                                std::ostream *os)
{
    bool hasArguments = false;

    *os << "vertex " << returnType << " " << desiredEntryName << "(\n";

    for (const VertexAttribute &attrib : attribs)
    {
        if (hasArguments)
        {
            *os << ",\n";
        }

        *os << "const device uchar *" << GetVertexBufferNamePrefix(attrib.index)
            << "AsByte1 [[buffer(" << attrib.index
            << "), function_constant(ANGLEVertexAttribIsUnaligned" << attrib.index << ")]],\n";

        *os << "const device uchar2 *" << GetVertexBufferNamePrefix(attrib.index)
            << "AsByte2 [[buffer(" << attrib.index
            << "), function_constant(ANGLEVertexAttribSrcUChar2_" << attrib.index << ")]],\n";

        *os << "const device uchar3 *" << GetVertexBufferNamePrefix(attrib.index)
            << "AsByte3 [[buffer(" << attrib.index
            << "), function_constant(ANGLEVertexAttribSrcUChar3_" << attrib.index << ")]],\n";

        *os << "const device uchar4 *" << GetVertexBufferNamePrefix(attrib.index)
            << "AsByte4 [[buffer(" << attrib.index
            << "), function_constant(ANGLEVertexAttribSrcUChar4_" << attrib.index << ")]],\n";

        *os << "const device ushort *" << GetVertexBufferNamePrefix(attrib.index)
            << "AsShort1 [[buffer(" << attrib.index
            << "), function_constant(ANGLEVertexAttribSrcUShort1_" << attrib.index << ")]],\n";

        *os << "const device ushort2 *" << GetVertexBufferNamePrefix(attrib.index)
            << "AsShort2 [[buffer(" << attrib.index
            << "), function_constant(ANGLEVertexAttribSrcUShort2_" << attrib.index << ")]],\n";

        *os << "const device ushort3 *" << GetVertexBufferNamePrefix(attrib.index)
            << "AsShort3 [[buffer(" << attrib.index
            << "), function_constant(ANGLEVertexAttribSrcUShort3_" << attrib.index << ")]],\n";

        *os << "const device ushort4 *" << GetVertexBufferNamePrefix(attrib.index)
            << "AsShort4 [[buffer(" << attrib.index
            << "), function_constant(ANGLEVertexAttribSrcUShort4_" << attrib.index << ")]],\n";

        *os << "const device uint *" << GetVertexBufferNamePrefix(attrib.index)
            << "AsInt1 [[buffer(" << attrib.index
            << "), function_constant(ANGLEVertexAttribSrcUInt1_" << attrib.index << ")]],\n";

        *os << "const device uint2 *" << GetVertexBufferNamePrefix(attrib.index)
            << "AsInt2 [[buffer(" << attrib.index
            << "), function_constant(ANGLEVertexAttribSrcUInt2_" << attrib.index << ")]],\n";

        *os << "const device uint3 *" << GetVertexBufferNamePrefix(attrib.index)
            << "AsInt3 [[buffer(" << attrib.index
            << "), function_constant(ANGLEVertexAttribSrcUInt3_" << attrib.index << ")]],\n";

        *os << "const device uint4 *" << GetVertexBufferNamePrefix(attrib.index)
            << "AsInt4 [[buffer(" << attrib.index
            << "), function_constant(ANGLEVertexAttribSrcUInt4_" << attrib.index << ")]]";

        hasArguments = true;
    }

    for (const FunctionParam &param : params)
    {
        if (param.type == FunctionParamType::StageIn ||
            param.type == FunctionParamType::VertexIndex ||
            param.type == FunctionParamType::InstanceIndex)
        {
            // Ignore, we declare our own variables
            continue;
        }

        if (hasArguments)
        {
            *os << ",\n";
        }

        *os << param.addressSpace << " " << param.typeName << " " << param.name << " "
            << param.attributes;

        hasArguments = true;
    }

    {
        // Insert buffer containing offset & stride for each attribute
        if (hasArguments)
        {
            *os << ",\n";
        }
        *os << "constant uint2* " << kVertexOffsetStrideBufferName << "[[buffer("
            << kAttribsOffsetStrideBufferBindingIndex << ")]]";
        hasArguments = true;
    }

    {
        // Insert vertex idx variable
        if (hasArguments)
        {
            *os << ",\n";
        }
        *os << "uint gl_VertexIndex [[vertex_id]]";
        hasArguments = true;
    }

    {
        // Insert instance idx variable
        if (hasArguments)
        {
            *os << ",\n";
        }
        *os << "uint gl_InstanceIndex [[instance_id]]";
        hasArguments = true;
    }

    *os << "\n)\n";

    return *os;
}

std::ostream &EmitVertexFetchCode(const FunctionParam &stageInput,
                                  const VertexAttribute &attrib,
                                  std::ostream *os)
{
    *os << "\t// fetching code for attribute" << attrib.index << "\n";
    *os << "\t{\n";

    *os << "\t\t  uint2 ANGLEOffsetStride_tmp = " << kVertexOffsetStrideBufferName << "["
        << attrib.index << "];\n";

    *os << "\t\tFETCH_CODE(\n";
    *os << "\t\t" << GetVertexTypeConstantName(attrib.index) << ",\n";
    *os << "\t\t" << GetVertexSizeConstantName(attrib.index) << ",\n";
    *os << "\t\t" << GetVertexBufferNamePrefix(attrib.index) << ",\n";
    *os << "\t\tANGLEOffsetStride_tmp.x,\n";
    *os << "\t\tANGLEOffsetStride_tmp.y,\n";
    *os << "\t\t" << GetVertexNormalizeConstantName(attrib.index) << ",\n";
    *os << "\t\t" << GetVertexOffsetAlignedConstantName(attrib.index) << ",\n";
    *os << "\t\t" << GetVertexDivisorConstantName(attrib.index) << ",\n";
    *os << "\t\t" << stageInput.name << '.' << attrib.name << "\n";
    *os << "\t\t);\n";

    *os << "\t}\n";
    *os << "\t// end fetching code for attribute" << attrib.index << "\n\n";

    return *os;
}

std::ostream &EmitVerticesFetchCode(const std::string &desiredEntryName,
                                    const std::string &oldEntryName,
                                    const std::string &returnType,
                                    const std::vector<FunctionParam> &params,
                                    std::vector<FunctionParam>::const_iterator stageInParamIte,
                                    const std::vector<VertexAttribute> &attribs,
                                    std::ostream *os)
{
    EmitConstantsDecls(attribs, os);
    EmitHelperFunctions(os);

    EmitVertexFetchCodeEntryPrototype(desiredEntryName, returnType, params, attribs, os);

    *os << "{" << std::endl;

    if (stageInParamIte != params.end())
    {
        // Declare attribute input for the old entry point
        *os << "\t" << stageInParamIte->typeName << " " << stageInParamIte->name << " = {};"
            << std::endl;

        // Fetch vertex attributes
        for (const VertexAttribute &attrib : attribs)
        {
            EmitVertexFetchCode(*stageInParamIte, attrib, os);
        }

    }  // if (stageInParamIte != params.end())

    // Finally call old entry function
    *os << '\t';
    if (returnType != "void")
    {
        *os << "return ";
    }

    *os << oldEntryName << "(";
    bool hasArg = false;
    for (const FunctionParam &param : params)
    {
        if (hasArg)
        {
            *os << ", ";
        }

        if (param.type == FunctionParamType::VertexIndex)
        {
            // We pass in our own variable
            *os << "gl_VertexIndex";
        }
        else if (param.type == FunctionParamType::InstanceIndex)
        {
            // We pass in our own variable
            *os << "gl_InstanceIndex";
        }
        else
        {
            *os << param.name;
        }
        hasArg = true;
    }

    *os << ");" << std::endl;
    *os << "}" << std::endl;

    return *os;
}

}  // namespace

std::string AppendVertexFetchingCode(const std::string &desiredEntryName,
                                     const std::string &mslSource)
{
    // Find entry point's prototype
    // $1 = return type, $2 = entry name, $3 = parameters
    std::regex mainDeclareRegex(R"(vertex\s+([_a-zA-Z0-9<>]+)\s+([_a-zA-Z0-9<>]+)\s*([^\{]*)\{)");
    std::smatch oldEntryEatchResults;
    if (!std::regex_search(mslSource, oldEntryEatchResults, mainDeclareRegex))
    {
        return mslSource;
    }

    std::string returnType       = oldEntryEatchResults[1];
    std::string wrappedEntryName = oldEntryEatchResults[2];
    std::string parameters       = oldEntryEatchResults[3];

    std::vector<FunctionParam> params = ParseMslParams(parameters);

    // Find stage_in struct declaration
    std::string stageInTypeDecl;
    std::vector<FunctionParam>::const_iterator stageInIte = std::find_if(
        params.begin(), params.end(),
        [](const FunctionParam &param) { return param.type == FunctionParamType::StageIn; });

    if (stageInIte != params.end())
    {
        std::ostringstream ss;
        ss << "(struct|class)\\s+" << stageInIte->typeName << "[^\\}]+\\}";
        std::string regexStr = ss.str();
        std::regex stageInTypeDeclRegex(regexStr);
        std::smatch matchResults2;
        if (std::regex_search(mslSource, matchResults2, stageInTypeDeclRegex))
        {
            stageInTypeDecl = matchResults2[0];
        }
    }

    std::vector<VertexAttribute> attribs = ParseMslAttributes(stageInTypeDecl);

    std::ostringstream ss;
    EmitVerticesFetchCode(desiredEntryName, wrappedEntryName, returnType, params, stageInIte,
                          attribs, &ss);

    std::string convertedSrc = mslSource + ss.str();

    // Remove "vertex" from old entry point
    std::string::const_iterator vertexMatchIte = oldEntryEatchResults[0].first;
    const size_t vertexKeywordIdx              = vertexMatchIte - mslSource.cbegin();
    for (size_t i = 0; i < 6; ++i)
    {
        convertedSrc[vertexKeywordIdx + i] = ' ';
    }

    return convertedSrc;
}

void PopulateVertexFetchingConstants(const VertexDesc &vertexDesc,
                                     MTLFunctionConstantValues *funcConstants)
{
    for (uint32_t i = 0; i < ArraySize(vertexDesc.attributes); ++i)
    {
        const VertexAttributeDesc &attribDesc = vertexDesc.attributes[i];
        if (attribDesc.source == VertexAttributeSource::None)
        {
            continue;
        }

        uint32_t type       = ConvertVertexTypeToShaderEnumValue(attribDesc.type);
        uint32_t components = attribDesc.channels;
        uint32_t divisor    = attribDesc.divisor;
        BOOL aligned        = attribDesc.isAligned ? YES : NO;
        BOOL normalize      = attribDesc.isNorm ? YES : NO;

        SetFunctionConstantUInt(funcConstants, type, GetVertexTypeConstantName(i));
        SetFunctionConstantUInt(funcConstants, components, GetVertexSizeConstantName(i));
        SetFunctionConstantUInt(funcConstants, divisor, GetVertexDivisorConstantName(i));
        SetFunctionConstantBool(funcConstants, aligned, GetVertexOffsetAlignedConstantName(i));
        SetFunctionConstantBool(funcConstants, normalize, GetVertexNormalizeConstantName(i));
    }
}

}  // namespace mtl
}  // namespace rx
